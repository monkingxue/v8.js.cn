<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Torque user manual · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li><a href=/blog>博客</a><li class=active><a href=/docs>文档</a></ul></nav></header><main id=main><h1>Torque user manual</h1><p>Torque is a language that allows developers contributing to the V8 project to express changes in the VM by focusing on their <em>intent</em> of their changes to the VM, rather than preoccupying themselves with unrelated implementation details. The language was designed to be simple enough to make it easy to directly translate the <a href=https://tc39.github.io/ecma262/ >ECMAScript specification</a> into an implementation in V8, but powerful enough to express the low-level V8 optimization tricks in a robust way, like creating fast-paths based on tests for specific object-shapes.<p>Torque will be familiar to V8 engineers and JavaScript developers, combining a TypeScript-like syntax that eases both writing and understanding V8 code with syntax and types that reflects concepts that are already common in the <a href=/blog/csa><code>CodeStubAssembler</code></a>. With a strong type system and structured control flow, Torque ensures correctness by construction. Torque’s expressiveness is sufficient to express almost all of the functionality that is <a href=/docs/builtin-functions>currently found in V8’s builtins</a>. It also is very interoperable with <code>CodeStubAssembler</code> builtins and <code>macro</code>s written in C++, allowing Torque code to use hand-written CSA functionality and vice-versa.<p>Torque provides language constructs to represent high-level, semantically-rich tidbits of V8 implementation, and the Torque Compiler converts these morsels into efficient assembly code using the <code>CodeStubAssembler</code>. Both Torque’s language structure and the Torque compiler’s error checking ensure correctness in ways that were previously laborious and error-prone with direct usage of the <code>CodeStubAssembler</code>. Traditionally, writing optimal code with the <code>CodeStubAssembler</code> required V8 engineers to carry a lot of specialized knowledge in their heads — much of which was never formally captured in any written documentation — to avoid subtle pitfalls in their implementation. Without that knowledge, the learning curve for writing efficient builtins was steep. Even armed with the necessary knowledge, non-obvious and non-policed gotchas often led to correctness or <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=775888">security</a> <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=785804">bugs</a>. With Torque, many of these pitfalls can be avoided and recognized automatically by the Torque compiler.<h2 id=getting-started>Getting started <a href=#getting-started aria-hidden=true class=bookmark>#</a></h2><p>Most source written in Torque is checked into the V8 repository under <a href=https://github.com/v8/v8/tree/master/src/builtins>the <code>src/builtins</code> directory</a>, with the file extension <code>.tq</code>. (The actual Torque Compiler can be found under <a href=https://github.com/v8/v8/tree/master/src/torque><code>src/torque</code></a>.). Tests for Torque functionality are checked in under <a href=https://github.com/v8/v8/tree/master/test/torque><code>test/torque</code></a>.<p>To give you a flavor of the language, let’s write a V8 builtin that prints “Hello World!”. To do this, we’ll add a Torque <code>macro</code> in a test case and call it from the <code>cctest</code> test framework.<p>First, open up the <code>test/torque/test-torque.tq</code> file and add the following code at the end (but before the last closing <code>}</code>):<pre class=language-torque><code class=language-torque><span class=highlight-line><span class="token keyword">macro</span> PrintHelloWorld<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  Print<span class="token punctuation">(</span><span class="token string">'Hello World!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span></span></code></pre><p>Now, open up <code>test/cctest/torque/test-torque.cc</code> and add the following test case that uses the new Torque code to build a code stub:<pre class=language-cpp><code class=language-cpp><span class=highlight-line><span class="token function">TEST</span><span class="token punctuation">(</span>HelloWorld<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  Isolate<span class="token operator">*</span> <span class="token function">isolate</span><span class="token punctuation">(</span>CcTest<span class="token operator">::</span><span class="token function">InitIsolateOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  CodeAssemblerTester <span class="token function">asm_tester</span><span class="token punctuation">(</span>isolate<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  TestBuiltinsFromDSLAssembler <span class="token function">m</span><span class="token punctuation">(</span>asm_tester<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  <span class="token punctuation">{</span></span><br><span class=highlight-line>    m<span class="token punctuation">.</span><span class="token function">PrintHelloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>    m<span class="token punctuation">.</span><span class="token function">Return</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">UndefinedConstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  <span class="token punctuation">}</span></span><br><span class=highlight-line>  FunctionTester <span class="token function">ft</span><span class="token punctuation">(</span>asm_tester<span class="token punctuation">.</span><span class="token function">GenerateCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  ft<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span></span></code></pre><p>Now <a href=/docs/test>build the <code>cctest</code> executable</a> and finally execute the <code>cctest</code> test to print ‘Hello World’:<pre class=language-bash><code class=language-bash><span class=highlight-line>$ out/x64.debug/cctest test-torque/HelloWorld</span><br><span class=highlight-line>Hello World<span class="token operator">!</span></span></code></pre><h2 id=how-torque-generates-code>How Torque generates code <a href=#how-torque-generates-code aria-hidden=true class=bookmark>#</a></h2><p>The Torque compiler doesn’t create machine code directly, but rather generates C++ code that calls V8’s existing <code>CodeStubAssembler</code> interface. The <code>CodeStubAssembler</code> uses the TurboFan compiler’s backend to generate efficient code. Torque compilation therefore requires multiple steps:<ol><li>The <code>gn</code> build first runs the Torque compiler. It processes all <code>*.tq</code> files, outputting corresponding <code>*-gen.cc</code> files (one <code>.cc</code> file per Torque module). The <code>.cc</code> files that are generated use TurboFan’s <code>CodeStubAssembler</code> interface for generating code.<li>The <code>gn</code> build then compiles the generated <code>.cc</code> files from step 1 into the <code>mksnapshot</code> executable.<li>When <code>mksnapshot</code> runs, all of V8’s builtins are generated and packaged in to the snapshot file, including those that are defined in Torque and any other builtins that use Torque-defined functionality.<li>The rest of V8 is built. All of Torque-authored builtins are made accessible via the snapshot file which is linked into V8. They can be called like any other builtin. In the final packaging, no direct traces of Torque remain (except for debug information): neither the Torque source code (<code>.tq</code> files) nor Torque-generated <code>.cc</code> files are included in the the <code>d8</code> or <code>chrome</code> executable.</ol><p>Graphically, the build process looks like this:<figure><img alt="" src=/_img/docs/torque/build-process.svg></figure><h2 id=torque-tooling>Torque tooling <a href=#torque-tooling aria-hidden=true class=bookmark>#</a></h2><p>Basic tooling and development environment support is available for Torque.<ul><li>There is a Visual Studio code syntax highlighting plugin available for Torque: <code>tools/torque/vscode-torque</code><li>There is also a formatting tool that should be used after changing <code>.tq</code> files: <code>tools/torque/format-torque.py -i &lt;filename></code></ul><h2 id=troubleshooting-builds-involving-torque>Troubleshooting builds involving Torque <a href=#troubleshooting-builds-involving-torque aria-hidden=true class=bookmark>#</a></h2><p>Why do you need to know this? Understanding how Torque files get converted into machine code is important because different problems (and bugs) can potentially arise in the different stages of translating Torque into the binary bits embedded in the snapshot:<ul><li>If you have a syntax or semantic error in Torque code (i.e. a <code>.tq</code> file), the Torque compiler fails. The V8 build aborts during this stage, and you will not see other errors that may be uncovered by later parts of the build.<li>Once your Torque code is syntactically correct and passes the Torque compiler’s (more or less) rigorous semantic checks, the build of <code>mksnapshot</code> can still fail. This most frequently happens with inconsistencies in external definitions provided in <code>.tq</code> files. Definitions marked with the <code>extern</code> keyword in Torque code signal to the Torque compiler that the definition of required functionality is found in C++. Currently, the coupling between <code>extern</code> definitions from <code>.tq</code> files and the C++ code to which those <code>extern</code> definitions refer is loose, and there is no verification at Torque-compile time of that coupling. When <code>extern</code> definitions don’t match (or in the most subtle cases mask) the functionality that they access in the <code>code-stub-assembler.h</code> header file or other V8 headers, the C++ build of <code>mksnapshot</code> fails, usually in <code>*-gen.cc</code> files.<li>Even once <code>mksnapshot</code> successfully builds, it can fail during execution if a Torque-provided builtin has a bug. Many builtins run as part of snapshot creation, including Torque-generated ones. For example, <code>Array.prototype.splice</code>, a Torque-authored builtin, is called as part of the JavaScript snapshot initialization process to setup the default JavaScript environment. If there is a bug in the implementation, <code>mksnapshot</code> crashes during execution. When <code>mksnapshot</code> crashes, it’s sometimes useful to call <code>mksnapshot</code> passing the <code>--gdb-jit-full</code> flag, which generates extra debug information that provides useful context, e.g. names for Torque-generated builtins in <code>gdb</code> stack crawls.<li>Of course, even if Torque-authored code makes it through <code>mksnapshot</code>, it still may be buggy or crash. Adding test cases to <code>torque-test.tq</code> and <code>torque-test.cc</code> is a good way to ensure that your Torque code does what you actually expect. If your Torque code does end up crashing in <code>d8</code> or <code>chrome</code>, the <code>--gdb-jit-full</code> flag is again very useful.</ul><h2 id=constexpr%3A-compile-time-vs.-run-time><code>constexpr</code>: compile-time vs. run-time <a href=#constexpr%3A-compile-time-vs.-run-time aria-hidden=true class=bookmark>#</a></h2><p>Understanding the Torque build process is also important to understanding a core feature in the Torque language: <code>constexpr</code>.<p>Torque allows evaluation of expressions in Torque code at runtime (i.e. when V8 builtins are executed as part of executing JavaScript). However, it also allows expressions to be executed at compile time (i.e. as part of the Torque build process and before the V8 library and <code>d8</code> executable have even been created).<p>Torque uses the <code>constexpr</code> keyword to indicate that an expression must be evaluated at build-time. Its usage is somewhat analogous to <a href=https://en.cppreference.com/w/cpp/language/constexpr>C++’s <code>constexpr</code></a>: in addition to borrowing the <code>constexpr</code> keyword and some of its syntax from C++, Torque similarly uses <code>constexpr</code> to indicate the distinction between evaluation at compile-time and runtime.<p>However, there are some subtle differences in Torque’s <code>constexpr</code> semantics. In C++, <code>constexpr</code> expressions can be evaluated completely by the C++ compiler. In Torque <code>constexpr</code> expressions cannot fully be evaluated by the Torque compiler, but instead map to C++ types, variables and expressions that can be (and must be) fully evaluated when running <code>mksnapshot</code>. From the Torque-writer’s perspective, <code>constexpr</code> expressions do not generate code executed at runtime, so in that sense they are compile-time, even though they are technically evaluated by C++ code external to Torque that <code>mksnapshot</code> runs. So, in Torque, <code>constexpr</code> essentially means “<code>mksnapshot</code>-time”, not “compile time”.<p>In combination with generics, <code>constexpr</code> is a powerful Torque tool that can be used to automate the generation of multiple very efficient specialized builtins that differ from each other in a small number of specific details that can be anticipated by V8 developers in advance.<h2 id=files>Files <a href=#files aria-hidden=true class=bookmark>#</a></h2><p>Torque code is packaged in individual source files. Each source file consists of a series of declarations, which themselves can optionally wrapped in a module declaration to separate the namespaces of declarations. The grammar for a <code>.tq</code> file is as follows:<pre><code class=language-grammar>Declaration :
  AbstractTypeDeclaration
  TypeAliasDeclaration
  CallableDeclaration
  ConstDeclaration
  GenericSpecialization

ModuleDeclaration :
  <b>module</b> IdentifierName <b>{</b> Declaration* <b>}</b>

FileDeclaration :
  ModuleDeclaration
  Declaration</code></pre><h2 id=modules>Modules <a href=#modules aria-hidden=true class=bookmark>#</a></h2><p>Torque modules allow declarations to be independent namespaces and they bear a similarity to C++ namespaces. They allow you to create declarations that are not automatically visible in other modules. Modules can be nested, and declarations inside a nested module can access the declarations in the module that contains them without qualification. Declarations that are not explicitly in a module declaration are put in a shared global default module that is visible to all modules. Modules can be reopened, allowing them to be defined over multiple files.<p>For example:<pre class=language-torque><code class=language-torque><span class=highlight-line><span class="token keyword">macro</span> IsJSObject<span class="token punctuation">(</span>o<span class="token class-name">: Object)</span><span class="token class-name">: bool {</span> … <span class="token punctuation">}</span>  <span class="token comment">// In default module</span></span><br><br><span class=highlight-line><span class="token keyword">module</span> array <span class="token punctuation">{</span></span><br><span class=highlight-line>  <span class="token keyword">macro</span> IsJSArray<span class="token punctuation">(</span>o<span class="token class-name">: Object)</span><span class="token class-name">: bool {</span> … <span class="token punctuation">}</span>  <span class="token comment">// In array module</span></span><br><span class=highlight-line><span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><br><span class=highlight-line><span class="token keyword">module</span> string <span class="token punctuation">{</span></span><br><span class=highlight-line>  <span class="token comment">// …</span></span><br><span class=highlight-line>  <span class="token keyword">macro</span> TestVisibility<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>    IsJsObject<span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK, global module visible here</span></span><br><span class=highlight-line>    IsJSArray<span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ERROR, not visible in this module</span></span><br><span class=highlight-line>  <span class="token punctuation">}</span></span><br><span class=highlight-line>  <span class="token comment">// …</span></span><br><span class=highlight-line><span class="token punctuation">}</span></span><br><br><span class=highlight-line><span class="token keyword">module</span> array <span class="token punctuation">{</span></span><br><span class=highlight-line>  <span class="token comment">// OK, module has been re-opened.</span></span><br><span class=highlight-line>  <span class="token keyword">macro</span> EnsureWriteableFastElements<span class="token punctuation">(</span>array<span class="token class-name">: JSArray)</span><span class="token punctuation">{</span> … <span class="token punctuation">}</span></span><br><span class=highlight-line><span class="token punctuation">}</span><span class="token punctuation">;</span></span></code></pre><p>Conceptually, a Torque module maps to a specific subclass of <code>CodeStubAssembler</code>, and most Torque module declarations map to C++ declarations in that subclass. When the Torque compiler process all of the <code>.tq</code> files in V8, all of the declarations in a module are collected and written out together into a predictably-named <code>CodeStubAssembler</code> subclass that’s generated at compile-time.<p>For example, the following module declaration specifies two Torque <code>macro</code>s in the <code>foo</code> module. (<code>macro</code>s are a Torque primitive that specifies how to generate a bunch of CSA code and they are discussed in more detail below, but for this example it suffices to know that they produce CSA-generating C++ code that would have been hand-written in a method of a <code>CodeStubAssembler</code> class in a pre-Torque world.)<pre class=language-torque><code class=language-torque><span class=highlight-line><span class="token keyword">module</span> foo <span class="token punctuation">{</span></span><br><span class=highlight-line>  <span class="token keyword">extern</span> <span class="token keyword">macro</span> Bar<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  <span class="token keyword">macro</span> Baz<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><br><span class=highlight-line><span class="token punctuation">}</span><span class="token punctuation">;</span></span></code></pre><p>This module declaration would result in two generated files in the build directory called <code>builtins-foo-gen-from-idl.h</code> and <code>builtins-foo-gen-from-idl.cc</code>. These files contain the declaration and definition of a <code>CodeStubAssembler</code>-derivative class containing the C++ that implements the Torque code in the <code>foo</code> namespace.<p>In this example, <code>builtins-foo-gen-from-idl.h</code> declares <code>FooBuiltinsFromDSLAssembler</code>, a subclass of a similarly-named <code>FooBuiltinsAssembler</code>. Both class names are mechanically generated by converting the module name to a CamelCase identifier:<pre class=language-cpp><code class=language-cpp><span class=highlight-line><span class="token keyword">class</span> <span class="token class-name">FooBuiltinsFromDSLAssembler</span><span class="token operator">:</span> <span class="token keyword">public</span> FooBuiltinsAssembler <span class="token punctuation">{</span></span><br><span class=highlight-line>  <span class="token keyword">public</span><span class="token operator">:</span></span><br><span class=highlight-line>    <span class="token comment">// …</span></span><br><span class=highlight-line>    <span class="token keyword">void</span> <span class="token function">Baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span><span class="token punctuation">;</span></span></code></pre><p><code>FooBuiltinsFromDSLAssembler</code> contains all of the Torque-implemented declarations for the <code>foo</code> namespace. In this case it only contains the method <code>Baz</code>, a C++ method that uses the CSA interface to generate code for <code>Baz</code>’s Torque implementation.<p>Note that module classes do not directly derive from the class of their parent module, but rather provide a level of indirection between themselves and their parent module’s superclass that allows direct CSA-based functionality to be added to the module. In this case, <code>FooBuiltinsFromDSLAssembler</code> subclasses <code>FooBuiltinsAssembler</code>, which must be provided as a pure-CSA implementation. It provides an intermediary place to put non-Torque implemented (i.e. hand-written CSA) functionality that also belongs to the module. In this example, <code>FooBuiltinsAssembler</code> must implement <code>Bar</code>, since it is declared in a Torque as an <code>external macro</code>, i.e. it is not implemented in Torque code but provided through a hand-written CSA implementation in C++.<p>New modules must be added to the <code>BUILD.gn</code> file in the <code>torque_modules</code> variable.<h2 id=declarations>Declarations <a href=#declarations aria-hidden=true class=bookmark>#</a></h2><h3 id=types>Types <a href=#types aria-hidden=true class=bookmark>#</a></h3><p>Torque is strongly typed. Its type system is the basis for many of the security and correctness guarantees it provides.<p>However, with a few notable exceptions discussed later, Torque doesn’t actually inherently know very much about the core types that are used to write most Torque code. In order to enable better interoperability between Torque and hand-written <code>CodeStubAssembler</code> code, Torque’s type system rigorously specifies the relationship between Torque types, but it is much less rigorous in specifying how the types themselves actually work. Instead, it is loosely coupled with <code>CodeStubAssembler</code> and C++ types through explicit type mappings, and it relies on the C++ compiler to enforce the rigor of that mapping.<p>In Torque, there are three different kinds of types: Abstract, Function and Union.<h4 id=abstract-types>Abstract types <a href=#abstract-types aria-hidden=true class=bookmark>#</a></h4><p>Torque’s abstract types map directly to C++ compile-time and CodeStubAssembler runtime values. Their declarations specify a name and a relationship to C++ types:<pre><code class=language-grammar>AbstractTypeDeclaration :
  <b>type</b> IdentifierName ExtendsDeclaration<sub>opt</sub> GeneratesDeclaration<sub>opt</sub> ConstexprDeclaration<sub>opt</sub>

ExtendsDeclaration :
  <b>extends</b> IdentifierName <b>;</b>

GeneratesDeclaration :
  <b>generates</b> StringLiteral <b>;</b>

ConstexprDeclaration :
  <b>constexpr</b> StringLiteral <b>;</b></code></pre><p><code>IdentifierName</code> specifies the name of the abstract type, and <code>ExtendsDeclaration</code> optionally specifies the type from which the declared type derives. <code>GeneratesDeclaration</code> optionally specifies a string literal which corresponds to the C++ <code>TNode</code> type used in <code>CodeStubAssembler</code> code to contain a runtime value of its type. <code>ConstexprDeclaration</code> is a string literal specifying the C++ type corresponding to the <code>constexpr</code> version of the Torque type for build-time (<code>mksnapshot</code>-time) evaluation.<p>Here’s an example from <code>base.tq</code> for Torque’s signed 31- and 32-bit signed integer types:<pre class=language-torque><code class=language-torque><span class=highlight-line><span class="token keyword">type</span> <span class="token class-name">int32</span> <span class="token keyword">generates</span> <span class="token string">'TNode&lt;Int32T>'</span> <span class="token keyword">constexpr</span> <span class="token string">'int32_t'</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token keyword">type</span> <span class="token class-name">int31</span> <span class="token keyword">extends</span> <span class="token class-name">int32</span> <span class="token keyword">generates</span> <span class="token string">'TNode&lt;Int32T>'</span> <span class="token keyword">constexpr</span> <span class="token string">'int31_t'</span><span class="token punctuation">;</span></span></code></pre><h4 id=union-types>Union types <a href=#union-types aria-hidden=true class=bookmark>#</a></h4><p>Union types express that a value belongs to one of several possible types. We only allow union types for tagged values, because they can be distinguished at runtime using the map pointer. For example, JavaScript numbers are either Smi values or allocated HeapNumber objects.<pre class=language-torque><code class=language-torque><span class=highlight-line><span class="token keyword">type</span> <span class="token class-name">Number</span> <span class="token operator">=</span> <span class="token class-name">Smi</span> <span class="token operator">|</span> HeapNumber<span class="token punctuation">;</span></span></code></pre><p>Union types satisfy the following equalities:<ul><li><code>A | B = B | A</code><li><code>A | (B | C) = (A | B) | C</code><li><code>A | B = A</code> if <code>B</code> is a subtype of <code>A</code></ul><p>It is only allowed to form union types from tagged types because untagged types cannot be distinguished at runtime.<p>When mapping union types to CSA, the most specific common supertype of all the types of the union type is selected, with the exception of <code>Number</code> and <code>Numeric</code>, which are mapped to the corresponding CSA union types.<h4 id=function-pointer-types>Function pointer types <a href=#function-pointer-types aria-hidden=true class=bookmark>#</a></h4><p>Function pointers can only point to builtins defined in Torque, since this guarantees the default ABI. They are especially useful to reduce binary code size.<p>While function pointer types are anonymous (like in C), they can be bound to a type alias (like a <code>typedef</code> in C).<pre class=language-torque><code class=language-torque><span class=highlight-line><span class="token keyword">type</span> <span class="token class-name">CompareBuiltinFn</span> <span class="token operator">=</span> <span class="token class-name">builtin</span><span class="token punctuation">(</span>Context<span class="token punctuation">,</span> Object<span class="token punctuation">,</span> Object<span class="token punctuation">,</span> Object<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> Number<span class="token punctuation">;</span></span></code></pre><h4 id=special-types>Special types <a href=#special-types aria-hidden=true class=bookmark>#</a></h4><p>There are two special types indicated by the keywords <code>void</code> and <code>never</code>. <code>void</code> is used as the return type for callables that do not return a value, and <code>never</code> is used as the return type for callables that never actually return (i.e. only exit through exceptional paths).<h3 id=callables>Callables <a href=#callables aria-hidden=true class=bookmark>#</a></h3><p>Callables are conceptually like functions in JavaScript or C++, but they have some additional semantics that allow them to interact in useful ways with CSA code and with the V8 runtime. Torque provides three types of callables: <code>macro</code>s, <code>builtin</code>s, and <code>runtime</code>s.<pre><code class=language-grammar>CallableDeclaration :
  MacroDeclaration
  BuiltinDeclaration
  RuntimeDeclaration</code></pre><h4 id=macro-callables><code>macro</code> callables <a href=#macro-callables aria-hidden=true class=bookmark>#</a></h4><p>Macros are a callable that correspond to a chunk of generated CSA-producing C++. <code>macro</code>s can either be fully defined in Torque, in which case the CSA code is generated by Torque, or marked <code>extern</code>, in which case the implementation must be provided as hand-written CSA code in a CodeStubAssembler class. Conceptually, it’s useful to think of <code>macro</code>s of chunks of inlinable CSA code that are inlined at callsites.<p><code>macro</code> declarations in Torque take the following form:<pre><code class=language-grammar>MacroDeclaration :
  <b>macro</b> IdentifierName ImplicitParameters<sub>opt</sub> ExplicitParameters ReturnType<sub>opt</sub> LabelsDeclaration<sub>opt</sub> StatementBlock
  <b>extern macro</b> IdentifierName ImplicitParameters<sub>opt</sub> ExplicitTypes ReturnType<sub>opt</sub> LabelsDeclaration<sub>opt</sub> <b>;</b>
</code></pre><p>Every non-<code>extern</code> Torque <code>macro</code> uses the <code>StatementBlock</code> body of the <code>macro</code> to create a CSA-generating function in its module’s generated <code>Assembler</code> class. This code looks just like other code that you might find in <code>code-stub-assembler.cc</code>, albeit a bit less readable because it’s machine-generated. <code>macro</code>s that are marked <code>extern</code> have no body written in Torque and simply provide the interface to hand-written C++ CSA code so that it’s usable from Torque.<p><code>macro</code> definitions specify implicit and explict parameters, an optional return type and optoinal labels. Parameters and return types will be discussed in more detail below, but for now it suffices to know that they work somewhat like TypeScript parameters, which as discussed in the Function Types section of the TypeScript documentation <a href=https://www.typescriptlang.org/docs/handbook/functions.html>here</a>.<p>Labels are a mechanism for exceptional exit from a <code>macro</code>. They map 1:1 to CSA labels and are added as <code>CodeStubAssemblerLabels*</code>-typed parameters to the C++ method generated for the <code>macro</code>. Their exact semantics are discussed below, but for the purpose of a <code>macro</code> declartion, the comma-separated list of a <code>macro</code>’s labels is optionally provided with the <code>labels</code> keywords and positioned after the <code>macro</code>’s parameter lists and return type.<p>Here’s an example from <code>base.tq</code> of external and Torque-defined <code>macro</code>s:<pre class=language-torque><code class=language-torque><span class=highlight-line><span class="token keyword">extern</span> <span class="token keyword">macro</span> BranchIfFastJSArrayForCopy<span class="token punctuation">(</span>Object<span class="token punctuation">,</span> Context<span class="token punctuation">)</span><span class="token class-name">: never</span><br><span class=highlight-line>    <span class="token keyword">labels</span></span> Taken<span class="token punctuation">,</span> NotTaken<span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token keyword">macro</span> BranchIfNotFastJSArrayForCopy<span class="token punctuation">(</span><span class="token keyword">implicit</span> context<span class="token class-name">: Context)</span><span class="token punctuation">(</span>o<span class="token class-name">: Object)</span><span class="token class-name">:</span><br><span class=highlight-line>    never</span><br><span class=highlight-line>    <span class="token keyword">labels</span></span> Taken<span class="token punctuation">,</span> NotTaken <span class="token punctuation">{</span></span><br><span class=highlight-line>  BranchIfFastJSArrayForCopy<span class="token punctuation">(</span>o<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token keyword">otherwise</span> NotTaken<span class="token punctuation">,</span> Taken<span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span></span></code></pre><h4 id=builtin-callables><code>builtin</code> callables <a href=#builtin-callables aria-hidden=true class=bookmark>#</a></h4><p><code>builtin</code>s are similar to <code>macro</code>s in that they can either be fully defined in Torque or marked <code>extern</code>. In the Torque-based builtin case, the body for the builtin is used to generate a V8 builtin that can be called just like any other V8 builtin, including automatically adding the relevant information in <code>builtin-definitions.h</code>. Like <code>macro</code>s, Torque <code>builtin</code>s that are mared <code>extern</code> have no Torque-based body and simply provide an interface to existing V8 <code>builtin</code>s so that they can be used from Torque code.<p><code>builtin</code> declarations in Torque have the following form:<pre><code class=language-grammar>MacroDeclaration :
  <b>javascript<sub>opt</sub></b> <b>builtin</b> IdentifierName ImplicitParameters<sub>opt</sub> ExplicitParametersOrVarArgs ReturnType<sub>opt</sub> StatementBlock
  <b>extern javascript<sub>opt</sub> builtin</b> IdentifierName ImplicitParameters<sub>opt</sub> ExplicitTypesOrVarArgs ReturnType<sub>opt</sub> <b>;</b>
</code></pre><p>There is only one copy of the code for a Torque builtin, and that is in the generated builtin code object. Unlike <code>macro</code>s, when <code>builtin</code>s are called from Torque code, the CSA code is not inlined at the callsite, but instead a call is generated to the builtin.<p><code>builtin</code>s cannot have labels.<h4 id=runtime-callables><code>runtime</code> callables <a href=#runtime-callables aria-hidden=true class=bookmark>#</a></h4><p><code>runtime</code>s are similar to <code>builtin</code>s in that they can expose an interface to external functionality to Torque. However, instead of being implemented in CSA, the functionality provided by a <code>runtime</code> must always be implemented in the V8 as a standard runtime callback.<p><code>runtime</code> declarations in Torque have the following form:<pre><code class=language-grammar>MacroDeclaration :
  <b>extern runtime</b> IdentifierName ImplicitParameters<sub>opt</sub> ExplicitTypesOrVarArgs ReturnType<sub>opt</sub> <b>;</b>
</code></pre><p>The <code>extern runtime</code> specified with name <i>IdentifierName</i> corresponds to the runtime function specified by Runtime::k<i>IdentifierName</i>.<p>Like builtins, <code>runtime</code>s cannot have labels.<h3 id=explicit-parameters>Explicit parameters <a href=#explicit-parameters aria-hidden=true class=bookmark>#</a></h3><p>Declarations of Torque-defined Callables, e.g. Torque <code>macro</code>s and <code>builtin</code>s, have explicit parameter lists. They are a list of identifier and type pairs using a syntax reminiscent of typed TypeScript function parameter lists, with the exception that Torque doesn't support optional parameters or default parameters. Moreover, Torque-implement <code>builtin</code>s can optonally support rest parameters if the builtin uses the V8's internal JavaScript calling convention (e.g. is marked with the <code>javascript</code> keyword).<pre><code class=language-grammar>ExplicitParameters :
  <b>(</b> ( IdentifierName <b>:</b> TypeIdentifierName )<sub>list*</sub> <b>)</b>
  <b>(</b> ( IdentifierName <b>:</b> TypeIdentifierName )<sub>list+</sub> (<b>, ...</b> IdentifierName )<sub>opt</sub> <b>)</b>
</code></pre><p>As an example:<pre class=language-torque><code class=language-torque><span class=highlight-line><span class="token keyword">javascript</span> <span class="token keyword">builtin</span> ArraySlice<span class="token punctuation">(</span></span><br><span class=highlight-line>    context<span class="token class-name">: Context,</span> receiver<span class="token class-name">: Object,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>arguments<span class="token punctuation">)</span><span class="token class-name">: Object {</span></span><br><span class=highlight-line>  <span class="token comment">// …</span></span><br><span class=highlight-line><span class="token punctuation">}</span></span></code></pre><h3 id=implicit-parameters>Implicit parameters <a href=#implicit-parameters aria-hidden=true class=bookmark>#</a></h3><p>Torque callables can specify implicit parameters using something similar to <a href=https://docs.scala-lang.org/tour/implicit-parameters.html>Scala’s implicit parameters</a>:<pre><code class=language-grammar>ImplicitParameters :
  <b>( implicit</b> ( IdentifierName <b>:</b> TypeIdentifierName )<sub>list*</sub> <b>)</b>
</code></pre><p>Concretely: A <code>macro</code> can declare implicit parameters in addition to explicit ones:<pre class=language-torque><code class=language-torque><span class=highlight-line><span class="token keyword">macro</span> Foo<span class="token punctuation">(</span><span class="token keyword">implicit</span> context<span class="token class-name">: Context)</span><span class="token punctuation">(</span>x<span class="token class-name">: Smi,</span> y<span class="token class-name">: Smi)</span></span></code></pre><p>When mapping to CSA, implicit parameters and explicit parameters are treated the same and form a joint parameter list.<p>Implicit parameters are not mentioned at the callsite, but instead are passed implicitly: <code>Foo(4, 5)</code>. For this to work, <code>Foo(4, 5)</code> must be called in a context that provides a value named <code>context</code>. Example:<pre class=language-torque><code class=language-torque><span class=highlight-line><span class="token keyword">macro</span> Bar<span class="token punctuation">(</span><span class="token keyword">implicit</span> context<span class="token class-name">: Context)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  Foo<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span></span></code></pre><p>In contrast to Scala, we forbid this if the names of the implicit parameters are not identical.<br>For overload resolution not to cause fragile and confusing behavior, we want that the implicit parameters do not influence overload resolution at all. That is: when comparing candidates of an overload set, we do not consider the available implicit bindings at the call-site. Only after we found a single best overload, we check if implicit bindings for the implicit parameters are available.<p>Having the implicit parameters left of the explicit parameters is different from Scala, but maps better to the existing convention in CSA to have the <code>context</code> parameter first.<h3 id=overload-resolution>Overload resolution <a href=#overload-resolution aria-hidden=true class=bookmark>#</a></h3><p>Torque <code>macro</code>s and operators (which are just aliases for <code>macro</code>s) allow for argument-type overloading. The overloading rules are inspired by the ones of C++: an overload is selected if it is strictly better than all alternatives. This means that it has to be strictly better in at least one parameter, and better or equally good in all others.<p>When comparing a pair of corresponding parameters of two overloads…<ul><li>…they are considered equally good if:<ul><li>they are equal;<li>both require some implicit conversion.</ul><li>… one is considered better if:<ul><li>it is a strict subtype of the other;<li>it doesn’t require an implicit conversion, while the other does.</ul></ul><p>If no overload is strictly better than all alternatives, this results in a compile error.</main><footer id=footer><nav><a href=https://v8.dev/docs/torque>原文</a> · <a href=/logo>商标</a> · <a href=/terms>条款</a> · <a href=https://policies.google.com/privacy>隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.dev/tree/master/./src/docs/torque.md rel=nofollow>在 GitHub 编辑此页面</a></nav><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>