<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Elements kinds in V8 · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog>博客</a><li><a href=/docs>文档</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline><i>Elements kinds</i> in V8</h1><p class=meta>发布时间：<time datetime="2017-09-12 13:33:37" itemprop=datePublished title="2017-09-12 13:33:37">2017-09-12</time> · 标签： <a href=/blog/tags/internals class=tag>internals</a> <a href=/blog/tags/presentations class=tag>presentations</a></header><div itemprop=articleBody><p>Note: if you prefer watching a presentation over reading articles, then enjoy the video below!<figure><iframe height=360 src=https://www.youtube.com/embed/m9cTaYI95Zc width=640></iframe></figure><p>JavaScript objects can have arbitrary properties associated with them. The names of object properties can contain any character. One of the interesting cases that a JavaScript engine can choose to optimize for are properties whose names are purely numeric, most specifically <a href=https://tc39.github.io/ecma262/#sec-object-type>array indices</a>.<p>In V8, properties with integer names — the most common form of which are objects generated by the <code>Array</code> constructor — are handled specially. Although in many circumstances these numerically-indexed properties behave just like other properties, V8 chooses to store them separately from non-numeric properties for optimization purposes. Internally, V8 even gives these properties a special name: <em>elements</em>. Objects have <a href=/blog/fast-properties>properties</a> that map to values, whereas arrays have indices that map to elements.<p>Although these internals are never directly exposed to JavaScript developers, they explain why certain code patterns are faster than others.<h2 id=common-elements-kinds>Common elements kinds <a href=#common-elements-kinds class=bookmark aria-hidden=true>#</a></h2><p>While running JavaScript code, V8 keeps track of what kind of elements each array contains. This information allows V8 to optimize any operations on the array specifically for this type of element. For example, when you call <code>reduce</code>, <code>map</code>, or <code>forEach</code> on an array, V8 can optimize those operations based on what kind of elements the array contains.<p>Take this array, for example:<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span></code></pre><p>What kinds of elements does it contain? If you’d ask the <code>typeof</code> operator, it would tell you the array contains <code>number</code>s. At the language-level, that’s all you get: JavaScript doesn’t distinguish between integers, floats, and doubles — they’re all just numbers. However, at the engine level, we can make more precise distinctions. The elements kind for this array is <code>PACKED_SMI_ELEMENTS</code>. In V8, the term Smi refers to the particular format used to store small integers. (We’ll get to the <code>PACKED</code> part in a minute.)<p>Later adding a floating-point number to the same array transitions it to a more generic elements kind:<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// elements kind: PACKED_SMI_ELEMENTS</span></span><br><span class=highlight-line>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4.56</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// elements kind: PACKED_DOUBLE_ELEMENTS</span></span></code></pre><p>Adding a string literal to the array changes its elements kind once again.<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// elements kind: PACKED_SMI_ELEMENTS</span></span><br><span class=highlight-line>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4.56</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// elements kind: PACKED_DOUBLE_ELEMENTS</span></span><br><span class=highlight-line>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// elements kind: PACKED_ELEMENTS</span></span></code></pre><p>We’ve seen three distinct elements kinds so far, with the following basic types:<ul><li><b>Sm</b>all <b>i</b>ntegers, also known as Smi.<li>Doubles, for floating-point numbers and integers that cannot be represented as a Smi.<li>Regular elements, for values that cannot be represented as Smi or doubles.</ul><p>Note that doubles form a more general variant of Smi, and regular elements are another generalization on top of doubles. The set of numbers that can be represented as a Smi is a subset of the numbers that can be represented as a double.<p>What’s important here is that elements kind transitions only go in one direction: from specific (e.g. <code>PACKED_SMI_ELEMENTS</code>) to more general (e.g. <code>PACKED_ELEMENTS</code>). Once an array is marked as <code>PACKED_ELEMENTS</code>, it cannot go back to <code>PACKED_DOUBLE_ELEMENTS</code>, for example.<p>So far, we’ve learned the following:<ul><li>V8 assigns an elements kind to each array.<li>The elements kind of an array is not set in stone — it can change at runtime. In the earlier example, we transitioned from <code>PACKED_SMI_ELEMENTS</code> to <code>PACKED_ELEMENTS</code>.<li>Elements kind transitions can only go from specific kinds to more general kinds.</ul><h2 id=packed-vs.-holey-kinds><code>PACKED</code> vs. <code>HOLEY</code> kinds <a href=#packed-vs.-holey-kinds class=bookmark aria-hidden=true>#</a></h2><p>So far, we’ve only been dealing with dense or packed arrays. Creating holes in the array (i.e. making the array sparse) downgrades the elements kind to its “holey” variant:<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4.56</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// elements kind: PACKED_ELEMENTS</span></span><br><span class=highlight-line>array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 5</span></span><br><span class=highlight-line>array<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// array[5] until array[8] are now holes</span></span><br><span class=highlight-line><span class="token comment">// elements kind: HOLEY_ELEMENTS</span></span></code></pre><p>V8 makes this distinction because operations on packed arrays can be optimized more aggressively than operations on holey arrays. For packed arrays, most operations can be performed efficiently. In comparison, operations on holey arrays require additional checks and expensive lookups on the prototype chain.<p>Each of the basic elements kinds we’ve seen so far (i.e. Smis, doubles, and regular elements) comes in two flavors: the packed and the holey version. Not only can we transition from, say, <code>PACKED_SMI_ELEMENTS</code> to <code>PACKED_DOUBLE_ELEMENTS</code>, we can also transition from any <code>PACKED</code> kind to its <code>HOLEY</code> counterpart.<p>To recap:<ul><li>The most common elements kinds come in <code>PACKED</code> and <code>HOLEY</code> flavors.<li>Operations on packed arrays are more efficient than operations on holey arrays.<li>Elements kinds can transition from <code>PACKED</code> to <code>HOLEY</code> flavors.</ul><h2 id=the-elements-kind-lattice>The elements kind lattice <a href=#the-elements-kind-lattice class=bookmark aria-hidden=true>#</a></h2><p>V8 implements this tag transitioning system as a <a href=https://en.wikipedia.org/wiki/Lattice_%28order%29>lattice</a>. Here’s a simplified visualization of that featuring only the most common elements kinds:<figure><img alt="" src=/_img/elements-kinds/lattice.svg></figure><p>It’s only possible to transition downwards through the lattice. Once a single floating-point number is added to an array of Smis, it is marked as DOUBLE, even if you later overwrite the float with a Smi. Similarly, once a hole is created in an array, it’s marked as holey forever, even when you fill it later.<p>V8 currently distinguishes <a href="https://cs.chromium.org/chromium/src/v8/src/elements-kind.h?l=14&rcl=ec37390b2ba2b4051f46f153a8cc179ed4656f5d">21 different elements kinds</a>, each of which comes with its own set of possible optimizations.<p>In general, more specific elements kinds enable more fine-grained optimizations. The further down the elements kind is in the lattice, the slower manipulations of that object might be. For optimal performance, avoid needlessly transitioning to less specific types — stick to the most specific one that’s applicable to your situation.<h2 id=performance-tips>Performance tips <a href=#performance-tips class=bookmark aria-hidden=true>#</a></h2><p>In most cases, elements kind tracking works invisibly under the hood and you don’t need to worry about it. But here are a few things you can do to get the greatest possible benefit from the system.<h3 id=avoid-creating-holes>Avoid creating holes <a href=#avoid-creating-holes class=bookmark aria-hidden=true>#</a></h3><p>Let’s say we’re trying to create an array, for example:<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// The array is sparse at this point, so it gets marked as</span></span><br><span class=highlight-line><span class="token comment">// `HOLEY_SMI_ELEMENTS`, i.e. the most specific possibility given</span></span><br><span class=highlight-line><span class="token comment">// the current information.</span></span><br><span class=highlight-line>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// Hold up, that’s a string instead of a small integer… So the kind</span></span><br><span class=highlight-line><span class="token comment">// transitions to `HOLEY_ELEMENTS`.</span></span><br><span class=highlight-line>array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span></span><br><span class=highlight-line>array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'c'</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// At this point, all three positions in the array are filled, so</span></span><br><span class=highlight-line><span class="token comment">// the array is packed (i.e. no longer sparse). However, we cannot</span></span><br><span class=highlight-line><span class="token comment">// transition to a more specific kind such as `PACKED_ELEMENTS`. The</span></span><br><span class=highlight-line><span class="token comment">// elements kind remains `HOLEY_ELEMENTS`.</span></span></code></pre><p>Once the array is marked as holey, it’s holey forever — even if it’s packed later! Any operation on the array from then on is potentially slower than it could be. If you plan on performing lots of operations on the array, and you’d like to optimize those operations, avoid creating holes in the array. V8 can deal with packed arrays more efficiently.<p>A better way of creating an array is to use a literal instead:<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// elements kind: PACKED_ELEMENTS</span></span></code></pre><p>If you don’t know all the values ahead of time, create an array, and later <code>push</code> the values to it.<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// …</span></span><br><span class=highlight-line>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>someValue<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// …</span></span><br><span class=highlight-line>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>someOtherValue<span class="token punctuation">)</span><span class="token punctuation">;</span></span></code></pre><p>This approach ensures that the array never transitions to a holey elements kind. As a result, V8 can optimize any future operations on the array more efficiently.<h3 id=avoid-reading-beyond-the-length-of-the-array>Avoid reading beyond the length of the array <a href=#avoid-reading-beyond-the-length-of-the-array class=bookmark aria-hidden=true>#</a></h3><p>A similar situation to hitting a hole occurs when reading beyond the length of the array, e.g. reading <code>array[42]</code> when <code>array.length === 5</code>. In this case, the array index <code>42</code> is out of bounds, the property is not present on the array itself, and so the JavaScript engine has to perform the same expensive prototype chain lookups.<p>Don’t write your loops like this:<pre class=language-js><code class=language-js><span class=highlight-line><span class="token comment">// Don’t do this!</span></span><br><span class=highlight-line><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> item<span class="token punctuation">;</span> <span class="token punctuation">(</span>item <span class="token operator">=</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  <span class="token function">doSomething</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span></span></code></pre><p>This code reads all the elements in the array, and then one more. It only ends once it finds an <code>undefined</code> or <code>null</code> element. (jQuery uses this pattern in a few places.)<p>Instead, write your loops the old-fashioned way, and just keep iterating until you hit the last element.<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  <span class="token keyword">const</span> item <span class="token operator">=</span> items<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  <span class="token function">doSomething</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span></span></code></pre><p>When the collection you’re looping over is iterable (as is the case for arrays and <code>NodeList</code>s), that’s even better: just use <code>for-of</code>.<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  <span class="token function">doSomething</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span></span></code></pre><p>For arrays specifically, you could use the <code>forEach</code> built-in:<pre class=language-js><code class=language-js><span class=highlight-line>items<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  <span class="token function">doSomething</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></code></pre><p>Nowadays, the performance of both <code>for-of</code> and <code>forEach</code> is on par with the old-fashioned <code>for</code> loop.<p>Avoid reading beyond the array’s length! Doing so is just as bad as hitting a hole in an array. In this case, V8’s bounds check fails, the check to see if the property is present fails, and then we need to look up the prototype chain.<h3 id=avoid-elements-kind-transitions>Avoid elements kind transitions <a href=#avoid-elements-kind-transitions class=bookmark aria-hidden=true>#</a></h3><p>In general, if you need to perform lots of operations on an array, try sticking to an elements kind that’s as specific as possible, so that V8 can optimize those operations as much as possible.<p>This is harder than it seems. For example, just adding <code>-0</code> to an array of small integers is enough to transition it to <code>PACKED_DOUBLE_ELEMENTS</code>.<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// PACKED_SMI_ELEMENTS</span></span><br><span class=highlight-line>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// PACKED_DOUBLE_ELEMENTS</span></span></code></pre><p>As a result, any future operations on this array are optimized in a completely different way than they would be for Smis.<p>Avoid <code>-0</code>, unless you explicitly need to differentiate <code>-0</code> and <code>+0</code> in your code. (You probably don’t.)<p>The same thing goes for <code>NaN</code> and <code>Infinity</code>. They are represented as doubles, so adding a single <code>NaN</code> or <code>Infinity</code> to an array of <code>SMI_ELEMENTS</code> transitions it to <code>DOUBLE_ELEMENTS</code>.<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// PACKED_SMI_ELEMENTS</span></span><br><span class=highlight-line>array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// PACKED_DOUBLE_ELEMENTS</span></span></code></pre><p>If you’re planning on performing lots of operations on an array of integers, consider normalizing <code>-0</code> and blocking <code>NaN</code> and <code>Infinity</code> when initializing the values. That way, the array sticks to the <code>PACKED_SMI_ELEMENTS</code> kind. This one-time normalization cost can be worth the later optimizations.<p>In fact, if you’re doing mathematical operations on an array of numbers, consider using a TypedArray. We have specialized elements kinds for those, too.<h3 id=prefer-arrays-over-array-like-objects>Prefer arrays over array-like objects <a href=#prefer-arrays-over-array-like-objects class=bookmark aria-hidden=true>#</a></h3><p>Some objects in JavaScript — especially in the DOM — look like arrays although they aren’t proper arrays. It’s possible to create array-like objects yourself:<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> arrayLike <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class=highlight-line>arrayLike<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span></span><br><span class=highlight-line>arrayLike<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span></span><br><span class=highlight-line>arrayLike<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'c'</span><span class="token punctuation">;</span></span><br><span class=highlight-line>arrayLike<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></span></code></pre><p>This object has a <code>length</code> and supports indexed element access (just like an array!) but it lacks array methods such as <code>forEach</code> on its prototype. It’s still possible to call array generics on it, though:<pre class=language-js><code class=language-js><span class=highlight-line>Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>forEach<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">,</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> index <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> value <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// This logs '0: a', then '1: b', and finally '2: c'.</span></span></code></pre><p>This code calls the <code>Array.prototype.forEach</code> built-in on the array-like object, and it works as expected. However, this is slower than calling <code>forEach</code> on a proper array, which is highly optimized in V8. If you plan on using array built-ins on this object more than once, consider turning it into an actual array beforehand:<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> actualArray <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>actualArray<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> index <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> value <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// This logs '0: a', then '1: b', and finally '2: c'.</span></span></code></pre><p>The one-time conversion cost can be worth the later optimizations, especially if you plan on performing lots of operations on the array.<p>The <code>arguments</code> object, for example, is an array-like object. It’s possible to call array builtins on it, but such operations won’t be fully optimized the way they could be for a proper array.<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> <span class="token function function-variable">logArgs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>forEach<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class=highlight-line>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> index <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> value <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token function">logArgs</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// This logs '0: a', then '1: b', and finally '2: c'.</span></span></code></pre><p>ES2015 rest parameters can help here. They produce proper arrays that can be used instead of the array-like <code>arguments</code> objects in an elegant way.<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> <span class="token function function-variable">logArgs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  args<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class=highlight-line>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> index <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span> value <span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token function">logArgs</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// This logs '0: a', then '1: b', and finally '2: c'.</span></span></code></pre><p>Nowadays, there’s no good reason to use the <code>arguments</code> object directly.<p>In general, avoid array-like objects whenever possible and use proper arrays instead.<h3 id=avoid-polymorphism>Avoid polymorphism <a href=#avoid-polymorphism class=bookmark aria-hidden=true>#</a></h3><p>If you have code that handles arrays of many different elements kinds, it can lead to polymorphic operations that are slower than a version of the code that only operates on a single elements kind.<p>Consider the following example, where a library function is called with various elements kinds. (Note that this is not the native <code>Array.prototype.forEach</code>, which has its own set of optimizations on top of the elements kinds-specific optimizations discussed in this article.)<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> <span class="token function function-variable">each</span> <span class="token operator">=</span> <span class="token punctuation">(</span>array<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>    <span class="token keyword">const</span> item <span class="token operator">=</span> array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line>    <span class="token function">callback</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  <span class="token punctuation">}</span></span><br><span class=highlight-line><span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token keyword">const</span> <span class="token function function-variable">doSomething</span> <span class="token operator">=</span> <span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><br><span class=highlight-line><span class="token function">each</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><br><span class=highlight-line><span class="token function">each</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> doSomething<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// `each` is called with `PACKED_ELEMENTS`. V8 uses an inline cache</span></span><br><span class=highlight-line><span class="token comment">// (or “IC”) to remember that `each` is called with this particular</span></span><br><span class=highlight-line><span class="token comment">// elements kind. V8 is optimistic and assumes that the</span></span><br><span class=highlight-line><span class="token comment">// `array.length` and `array[index]` accesses inside the `each`</span></span><br><span class=highlight-line><span class="token comment">// function are monomorphic (i.e. only ever receive a single kind</span></span><br><span class=highlight-line><span class="token comment">// of elements) until proven otherwise. For every future call to</span></span><br><span class=highlight-line><span class="token comment">// `each`, V8 checks if the elements kind is `PACKED_ELEMENTS`. If</span></span><br><span class=highlight-line><span class="token comment">// so, V8 can re-use the previously-generated code. If not, more work</span></span><br><span class=highlight-line><span class="token comment">// is needed.</span></span><br><br><span class=highlight-line><span class="token function">each</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">,</span> <span class="token number">3.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> doSomething<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// `each` is called with `PACKED_DOUBLE_ELEMENTS`. Because V8 has</span></span><br><span class=highlight-line><span class="token comment">// now seen different elements kinds passed to `each` in its IC, the</span></span><br><span class=highlight-line><span class="token comment">// `array.length` and `array[index]` accesses inside the `each`</span></span><br><span class=highlight-line><span class="token comment">// function get marked as polymorphic. V8 now needs an additional</span></span><br><span class=highlight-line><span class="token comment">// check every time `each` gets called: one for `PACKED_ELEMENTS`</span></span><br><span class=highlight-line><span class="token comment">// (like before), a new one for `PACKED_DOUBLE_ELEMENTS`, and one for</span></span><br><span class=highlight-line><span class="token comment">// any other elements kinds (like before). This incurs a performance</span></span><br><span class=highlight-line><span class="token comment">// hit.</span></span><br><br><span class=highlight-line><span class="token function">each</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> doSomething<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// `each` is called with `PACKED_SMI_ELEMENTS`. This triggers another</span></span><br><span class=highlight-line><span class="token comment">// degree of polymorphism. There are now three different elements</span></span><br><span class=highlight-line><span class="token comment">// kinds in the IC for `each`. For every `each` call from now on, yet</span></span><br><span class=highlight-line><span class="token comment">// another elements kind check is needed to re-use the generated code</span></span><br><span class=highlight-line><span class="token comment">// for `PACKED_SMI_ELEMENTS`. This comes at a performance cost.</span></span></code></pre><p>Built-in methods (such as <code>Array.prototype.forEach</code>) can deal with this kind of polymorphism much more efficiently, so consider using them instead of userland library functions in performance-sensitive situations.<p>Another example of monomorphism vs. polymorphism in V8 involves object shapes, also known as the hidden class of an object. To learn about that case, check out <a href=https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html>Vyacheslav’s article</a>.<h2 id=debugging-elements-kinds>Debugging elements kinds <a href=#debugging-elements-kinds class=bookmark aria-hidden=true>#</a></h2><p>To figure out a given object’s “elements kind”, get a debug build of <code>d8</code> (see <a href=/docs/build>“Building from source”</a>), and run:<pre class=language-bash><code class=language-bash><span class=highlight-line>out/x64.debug/d8 --allow-natives-syntax</span></code></pre><p>This opens a <code>d8</code> REPL in which <a href="https://cs.chromium.org/chromium/src/v8/src/runtime/runtime.h?l=20&rcl=05720af2b09a18be5c41bbf224a58f3f0618f6be">special functions</a> such as <code>%DebugPrint(object)</code> are available. The “elements” field in its output reveals the “elements kind” of any object you pass to it.<pre class=language-js><code class=language-js><span class=highlight-line>d8<span class="token operator">></span> <span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token function">DebugPrint</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>DebugPrint<span class="token punctuation">:</span> <span class="token number">0x1fbbad30fd71</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>JSArray<span class="token punctuation">]</span></span><br><span class=highlight-line> <span class="token operator">-</span> map <span class="token operator">=</span> <span class="token number">0x10a6f8a038b1</span> <span class="token punctuation">[</span>FastProperties<span class="token punctuation">]</span></span><br><span class=highlight-line> <span class="token operator">-</span> prototype <span class="token operator">=</span> <span class="token number">0x1212bb687ec1</span></span><br><span class=highlight-line> <span class="token operator">-</span> elements <span class="token operator">=</span> <span class="token number">0x1fbbad30fd19</span> <span class="token operator">&lt;</span>FixedArray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token constant">PACKED_SMI_ELEMENTS</span> <span class="token punctuation">(</span><span class="token constant">COW</span><span class="token punctuation">)</span><span class="token punctuation">]</span></span><br><span class=highlight-line> <span class="token operator">-</span> length <span class="token operator">=</span> <span class="token number">3</span></span><br><span class=highlight-line> <span class="token operator">-</span> properties <span class="token operator">=</span> <span class="token number">0x219eb0702241</span> <span class="token operator">&lt;</span>FixedArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">{</span></span><br><span class=highlight-line>    #length<span class="token punctuation">:</span> <span class="token number">0x219eb0764ac9</span> <span class="token operator">&lt;</span>AccessorInfo<span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">const</span> accessor descriptor<span class="token punctuation">)</span></span><br><span class=highlight-line> <span class="token punctuation">}</span></span><br><span class=highlight-line> <span class="token operator">-</span> elements<span class="token operator">=</span> <span class="token number">0x1fbbad30fd19</span> <span class="token operator">&lt;</span>FixedArray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">{</span></span><br><span class=highlight-line>           <span class="token number">0</span><span class="token punctuation">:</span> <span class="token number">1</span></span><br><span class=highlight-line>           <span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">2</span></span><br><span class=highlight-line>           <span class="token number">2</span><span class="token punctuation">:</span> <span class="token number">3</span></span><br><span class=highlight-line> <span class="token punctuation">}</span></span><br><span class=highlight-line><span class="token punctuation">[</span>…<span class="token punctuation">]</span></span></code></pre><p>Note that “COW” stands for <a href=https://en.wikipedia.org/wiki/Copy-on-write>copy-on-write</a>, which is yet another internal optimization. Don’t worry about that for now — that’s a topic for another blog post!<p>Another useful flag that’s available in debug builds is <code>--trace-elements-transitions</code>. Enable it to let V8 inform you whenever any elements kind transition takes place.<pre class=language-bash><code class=language-bash><span class=highlight-line>$ <span class="token function">cat</span> my-script.js</span><br><span class=highlight-line>const array <span class="token operator">=</span> <span class="token punctuation">[</span>1, 2, 3<span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line>array<span class="token punctuation">[</span>3<span class="token punctuation">]</span> <span class="token operator">=</span> 4.56<span class="token punctuation">;</span></span><br><br><span class=highlight-line>$ out/x64.debug/d8 --trace-elements-transitions my-script.js</span><br><span class=highlight-line>elements transition <span class="token punctuation">[</span>PACKED_SMI_ELEMENTS -<span class="token operator">></span> PACKED_DOUBLE_ELEMENTS<span class="token punctuation">]</span> <span class="token keyword">in</span> ~+34 at x.js:2 <span class="token keyword">for</span> 0x1df87228c911 <span class="token operator">&lt;</span>JSArray<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">></span> from 0x1df87228c889 <span class="token operator">&lt;</span>FixedArray<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">></span> to 0x1df87228c941 <span class="token operator">&lt;</span>FixedDoubleArray<span class="token punctuation">[</span>22<span class="token punctuation">]</span><span class="token operator">></span></span></code></pre></div><footer><div><img alt="" src=/_img/avatars/mathias-bynens.jpg height=96 lazyload=on srcset="/_img/avatars/mathias-bynens@2x.jpg 2x" width=96><p>作者：Mathias Bynens (<a href=https://twitter.com/mathias>@mathias</a>).</div><a href=https://twitter.com/v8js/status/907608362191376384 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><nav><a href=https://v8.dev/blog/elements-kinds>原文</a> · <a href=/logo>商标</a> · <a href=/terms>条款</a> · <a href=https://policies.google.com/privacy>隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.dev/tree/master/./src/blog/elements-kinds.md rel=nofollow>在 GitHub 编辑此页面</a></nav><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>